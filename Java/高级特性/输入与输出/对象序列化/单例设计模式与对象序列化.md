# 单例设计模式与对象序列化

---

使用单例设计模式往往会将类的构造方法的访问权限设置为私有的：

```java
public class Singleton implements Serializable{

    public static final Singleton SINGLETON = new Singleton(100);

    private int value;

    private Singleton(int value) {
        // private!
        this.value = value;
    }
}
```

创建单例类的目的就是保证类在全局只有一个实例，对单例类进行序列化时需要格外小心。下面看一段代码：

```java
public static void main(String[] args) throws IOException, ClassNotFoundException {
    Singleton singleton1 = Singleton.SINGLETON;

    ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream("singleton.dat"));
    output.writeObject(singleton1);

    ObjectInputStream input = new ObjectInputStream(new FileInputStream("singleton.dat"));
    Singleton singleton2 = (Singleton) input.readObject();

    System.out.println("创建新实例：" + (singleton1 != singleton2));
}
```

控制台输出：

```java
创建新实例：true
```

从上面代码的运行结果看，对单例类进行序列化可能产生新的实例。事实上，即使构造器是私有的，序列化机制也可能创建新的对象！

为了解决上述问题，需要定义一种被称为readResolve的特殊序列化方法。如果定义了readResolve方法，在对象序列化时就会调用它。

```java
public class Singleton implements Serializable {

    public static final Singleton SINGLETON = new Singleton(100);

    private int value;

    private Singleton(int value) {
        // private!
        this.value = value;
    }
    protected Object readResolve() throws ObjectStreamException {
        return SINGLETON;
    }
}
```

再次执行上面的测试代码，控制台输出如下：

```java
创建新实例：false
```

